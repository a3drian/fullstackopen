
Full Stack Open

--------------------Part 4, Testing Express servers, user administration--------------------

a. Structure of backend application, introduction to testing
----------------------------------------
Project structure
--------------------
Exercises 4.1-4.2.
--------------------
-se implementeaza ""
-(?)

Testing Node applications
--------------------
Exercises 4.3-4.7.
--------------------

b. Testing the backend
----------------------------------------
Test environment
--------------------
supertest
--------------------
Initializing the database before tests
--------------------
Running tests one by one
--------------------
async/await
--------------------
async/await in the backend
--------------------
More tests and refactoring the backend
--------------------
Error handling and async/await
--------------------
Eliminating the try-catch
--------------------
Optimizing the beforeEach function
--------------------
Exercises 4.8-4.12.
--------------------
Refactoring tests
--------------------
Exercises 4.13-4.14.
--------------------

c. User administration
----------------------------------------
References across collections
--------------------
Mongoose schema for users
--------------------
Creating users
--------------------
Creating a new note
--------------------
Populate
--------------------

d. Token authentication
----------------------------------------
Limiting creating new notes to logged in users
--------------------
Error handling
--------------------
End notes
--------------------
Exercises 4.15-4.22.
--------------------


--------------------Part 3, Programming a server with NodeJS and Express--------------------

a. Node.js and Express
----------------------------------------
-vom vorbi despre backend
-in backend, majoritatea caracteristicilor JavaScript sunt functionale, deci nu mai trebuie transpilat codul de exemplu, cu babel
-sub "main" se defineste the entry point of the application, la noi index.js
-practic "npm start" si "node index.js" sunt echivalente
-se folosesc teste in aplicatie cu "npm test"

Simple web server
--------------------
-momentan, server-ul returneaza acelasi raspuns indiferent de adresa URL, care poate fi: "http://localhost:3001/foo/bar", "http://localhost:4678", etc.
-"const http = require('http')" echivalent cu "import http from 'http'"
-modulul "http" este modulul built-in Node care creeaza un web-server
-Node foloseste modulele CommonJS, pentru ca nu suporta mereu ultimele functionalitati din modulele ES6
-prin "app.listen(3001)" se face practic binding intre web-server si un port, unde "app" este un server http creat prin metoda createServer()
.createServer() creeaza un web-server
-se defineste si un event handler pentru request-urile trimise catre server
-event handler-ul trimite un raspuns sub forma unor "notes" formatate JSON
-Content-Type s-a schimbat din "text/plain" in "application/json"

Express
--------------------
-instalam Express cu "npm install express --save"
-Express are nevoie de alte module, acele module au nevoie de alte module samd, asa numitele dependinte tranzitive
-cu "npm update" actualizam dependintele
-cu "npm install" se instaleaza dependintele daca nu avem folder-ul node_modules
-vorbeste putin de cum functioneaza versionarea "^4.17.1"

Web and express
--------------------
const express = require('express')
const app = express()
-"express" este de data asta o functie
-prin...
app.get('/', (req, res) => {
    res.send('<h1>Hello World!</h1>')
})
...se defineste ruta catre adresa "localhost:3001"
-se pot defini si alte rute pentru request-uri de tip GET cu metoda get()
-"req" = primul parametru, contine toate informatiile legate de request-ul HTTP
-"res" = al doilea parametru, continte toate informatiile legate despre cum vom trata raspunsul la request-ul HTTP definit prin variabila "req" de mai sus
-noi vom raspunde la request prin metoda "send()" in care vom trimite un element <h1> si un mesaj
-status code va fi default 200 si pentru ca am trimis un String => Content-Type este default "text/html"
-putem raspunde si cu metoda "json()" a parametrului "res"
-prin json() vom intoarce lista de "notes"
-de data asta, content-type va fi "application/json", dar cu acelasi status code 200
-nu mai avem nevoie de metoda stringify(), pentru ca transformarea din array in text formatat JSON se face automat
-de retinut ca un text formatat JSON nu este altceva decat un String:
const person = {
	name: "Arto",
	age: 35
}
const json = JSON.stringify(person)
-"person" este de fapt "'{"name":"Arto","age":35}"
-daca scrii in Command Prompt "node", poti scrie si testa, linie cu linie, comenzi JavaScript

nodemon
--------------------
-pentru aplicatie (si nu global) il instalam cu "npm install --save-dev nodemon"
-nodemon se va instala sub "devDependencies"
-in React, daca dai "npm run start" in Terminal, browser-ul da refresh automat cand detecteaza schimbari in codul sursa
.in React ai si "hot reload" care da refresh automat la browser
-cu nodemon putem obtine acelasi efect, dar trebuie totusi sa dam refresh manual in browser
-aplicatia nu are nevoie de modulele de sub "devDependencies" pentru a rula in production mode, ci doar in development mode
-daca adaugam "dev": "nodemon index.js" sub "scripts", atunci putem rula "npm run dev" care va porni server-ul
-se observa ca trebuie sa specificam "run" in comanda
.pentru "start" si "test" nu aveam nevoie de "run"

REST
--------------------
-singular things = "notes" = resources
-fiecare resursa are asociata o adresa URL care este o adresa unica spre aceasta resursa
-se practica folosirea tipului resursei si id-ul acesteia pentru a crea o adresa unica,
"www.example.com/api/notes/10", daca presupunem ca adresa radacina este "www.example.com/api"
-la noi tipul este "notes" si id-ul este 10
-intreaga colectie de "notes" se gaseste la o adresa in care nu se pune id:
"www.example.com/api/notes/"
-un tabel cu verbele ce pot fi folosite in request-uri HTPP, vezi si tabel-verbe.png:
URL			verb 	functionality
------------------------------------------------------------------------------------
notes/10 	GET 	fetches a single resource
notes 		GET 	fetches all resources in the collection
notes 		POST 	creates a new resource based on the request data
notes/10 	DELETE 	removes the identified resource
notes/10 	PUT 	replaces the entire identified resource with the request data
notes/10 	PATCH 	replaces a part of the identified resource with the request data
-GET = returneaza ori o singura resursa deja existenta ori toate resursele deja existente, vezi tabelul de mai sus
-POST = creezi o noua resursa
-DELETE = stergi o anumita resursa deja existenta
-PATCH = inlocuiesti doar anumite proprietati dintr-o resursa deja existenta
-PUT = inlocuiesti cu totul o resursa deja existenta
-in gandirea REST, prin tabelul de mai sus definim un "uniform interface", adica o interfata care permite sistemelor sa inter-opereze intre ele

Fetching a single resource
--------------------
-am folosit ":" intr-o ruta pentru a indica Express ca este vorba de un parametru:
app.get('/api/notes/:id', (request, response) => {..}
.observa ":id" de mai sus
-aceasta ruta va fi event handler-ul pentru toate request-urile GET la adresele de genul: "api/notes/1", "api/notes/12", etc.
.desigur, "id" poate fi orice String, adica "api/notes/aditza"
-se observa ca am accesat parametrul "id" prin intermediul obiectului "request" si proprietatea acestuia "params":
const id = request.params.id;
-ce se intampla in aceasta ruta este ca se face un request la adresa sa zicem, "api/notes/12"
-acel "12" este preluat prin obiectul "request" si salvat in constanta "id" => const id = request.params.id;
-cu acea constanta vom cauta pe server acea "note" care se potriveste id-ului
-cand o vom gasi o vom trimite ca raspuns prin "response.json(note)", adica un text formatat JSON
-se intoarce ca raspuns o pagina blank => debug
-am folosit...
console.log(note.id, typeof note.id, id, typeof id, note.id === id)
...si prin "typeof" ne-am dat seama ca se compara un "id" de tip Number cu un "id" de tip "String" si nu gaseste astfel o "note" => "undefined"
-retinem ca daca vrem mai mult de o instructiune intr-o functie cu "=>" trebuie sa folosim "{}"
-de asemenea, avem nevoie acum de "return note" pentru ca nu va mai fi recunoscut obiectul "note":
app.get('/api/notes/:id', (request, response) => {
    const id = Number(request.params.id)
    console.log('id:', id)
	
    const note = notes.find(note => {
        console.log(note.id, typeof note.id, id, typeof id, note.id === id);
        return note.id === id;
    })
	
    console.log('note:', note)
    response.json(note);
})
-in plus, deoarece "notes" este "undefined" atunci cand nu se gaseste un "note" cu acel "id" vom primi status code 200 in loc de 404
.adica practic nu a aparut eroare si atunci totul e in regula => status code 200
-poti verifica faptul ca de la server nu ai primit raspuns daca te uiti la "Content-Length" in "Headers", sub "Network": daca e 0, atunci server-ul a trimis un raspuns gol
-daca folosim "end()" ca raspuns inseamna ca am raspuns la request fara a trimite date
-obiectul "note" nu este acelasi ca cel folosit in return, vezi scope-of-note.png (?):
-prin "return note => note.id === id;" tu practic creezi o noua functie, diferita de "find()" si deci rezulta ca obiectele numite "note" nu mai corespund
."return note => note.id === id;" este echivalent cu...
return note => {
	note.id === id;
}
...si se observa ca este o functie noua care ia ca parametru un obiect "note" diferit de cel definit in "notes.find(note => {..})"
-"undefined" este falsy
-toate obiectele din JavaScript sunt truthy => if(object){..} => returneaza true doar daca nu este "undefined" sau "null"
-doarece lucram cu REST APIs, este suficient sa trimitem ca raspuns status code 404, fara a fi nevoie de a afisa efectiv ceva in pagina web

Deleting resources
--------------------
-vom folsi verbul DELETE in loc de GET
-de asemenea, vom folosi filter() ca sa nu afisam acea "note" care tocmai a fost stearsa
-raspundem cu status code 204 => NO CONTENT => raspunsul va fi fara date
-daca se incearca stergerea unei "note" care nu exista => status code 204 sau 404
-vom folosi tot 204 daca se incearca stergerea unei "note" care nu exista
-doar accesand adresa "http://localhost:3001/api/notes/2" nu inseamna ca se va sterge "note" cu id-ul 2
-trebuie sa folosim Postman ca sa trimitem un request de tip DELETE, pentru ca browser-ul face unul default de GET

Postman
--------------------
-o alternativa este "curl"
-tot ce trebuie sa facem este sa luam adresa si sa selectem ca request unul de tip DELETE
-rezultatul in Postman ar trebui sa fie cel din cod, adica sa returneze status code 204

The Visual Studio Code REST client
--------------------
-practic acelasi lucru cu Postman
-folosim fisiere cu extensia .rest, de exemplu get_all_notes.rest in care scriem:
GET http://localhost:3001/api/notes
-apare butonul "Send Request" in acest fisier .rest
-raspunsul apare intr-un tab in VSC

Receiving data
--------------------
-avem nevoie de un request POST si de json-parser din Express
-json-parser ne ajuta sa accesam continutul din corpul request-ului POST prin "request.body"
-trebuie sa trimitem la adresa "http://localhost:3001/api/notes" un "note" care sa fie inclus in corpul request-ului
-fara acel json-parser, acea proprietate "body" ar fi "undefined"
-json-parser functioneaza astfel:
.ia datele JSON dintr-un request
.transforma datele intr-un obiect JavaScript
.ataseaza obiectul la proprietatea "body" a obiectului "request" inainte sa se apelez route handler-ul pentru request
-in Postman, daca vrem sa trimitem un "note" trebuie sa umplem si tab-ul "Body" cu, de ex.:
{
	"content": "Postman is nice",
	"important": true
}
-de asemenea, punem "raw" si "JSON" ca tipul textului
-am pus "api/notes" in loc de "/api/notes" ca adresa si imi dadea 404 NOT FOUND
-daca punem Content-Type "text/plain" in loc de in loc sa primim inapoi...
{
	"content": "Postman is nice",
	"important": true
}
...vom primi "{}" adica un obiect gol, pentru ca server-ul nu poate interpreta corect request-ul si nici macar nu incearca sa isi dea seama ca tu ai vrut de fapt un request JSON
-putem folosi si REST Client din VSC
-fata de Postman, e mai simplu sa distribui aceste request-uri catre alti membri ai echipei, pentru ca sunt toate in folder-ul "request" din directorul aplicatiei si pot fi incluse in repo
-ca sidenote, poti sa verifica ca s-a trimis Content-Type corect daca printezi:
console.log(request.headers);
-de asemenea, poti verifica ce header-e s-au trimis in request daca folosesti metoda get() pe obiectul request:
req.get('Content-Type');
-codul de sus intoarce continutul header-ului "Content-Type"
-daca vrei sa folosesti REST Client, nu pune spatiu intre verbul de request si header...
POST http://localhost:3001/api/notes

Content-Type: application/json
...ci in schimb scrie:
POST http://localhost:3001/api/notes
Content-Type: application/json
-astfel, se evita problemele in care vei primi ca raspuns "{}" adica un obiect gol, dar si alte probleme legate de setarea header-ului necorespunzator
-daca header-ul "Content-Type" este setat necorespunzator, atunci server-ul nu stie sa interpreteze corect request-ul => {}
-mai intai am verificat ca server-ul primeste datele JSON, acum terminam aplication logic
-trebuie sa fortam utilizatorii sa trimita un "note" care contine ceva, adica sa nu trimita un text gol
-daca trimit un text gol => status code 400
-daca nu am apela "return" atunci cand nu se trimite continut in proprietatea "content" a unui "note", nu se iese din functie si atunci se va salva pe server o "note" care este corupta => daca nu se trimite continut in proprietatea "content" => return si eroare
-eroarea va fi status code 400 BAD REQUEST, adica clientul nu si-a facut treaba si nu a trimis continutul care trebuie pentru "note" pentru ca aceasta sa poata fi salvata pe server
-vom suprascrie data la care a fost scrisa "note" pentru ca nu stim cu siguranta ca ceasurile server-ului si clientului sunt sincronizate => lasam pe server sa creeze el o data
-daca lipseste proprietatea "important" => false
.cand "important" este false, atunci expresia...
body.important || false
...se evalueaza la false
-"? Math.max(...notes.map(n => n.id))" inseamna ca:
.se creeaza un map (un array) cu toate id-urile "note"-urilor deja existente
.practic se creaaza un array de id-uri "[1, 2, 3, 5, 6, 7]"
.se cauta maximul dintre aceste id-uri, dar nu se poate pentru ca Math.max() vrea ca parametru numere individuale si nu direct un array
.de aceea folosim object spread syntax "...notes" => va transforma array-ul in numere individuale care pot fi trimise ca parametru: "1 2 3 5 6 7"

Exercises 3.1-3.6
--------------------
-se implementeaza "Phonebook backend"
-(?)

About HTTP request types
--------------------
-tipurile de request: safe si idempotente
-GET si HEAD ar trebui sa fie safe
-safe = ca nu aduc nicio modificare asupra server-ului, nu aduc nicio modificare asupra bazei de date stocata pe server
-GET si HEAD trebuie doar sa aduca date de pe server
-cand se folosesc GET si HEAD, server-ul returneaza un "raspuns"
-cu GET se aduc resurse de pe server, header-e si status codes din acel raspuns
-cu HEAD se aduc doar header-ele si status code din header-ul acelui raspuns
-nu se garanteaza ca GET si HEAD sunt safe, dar daca aderam la principiile REST (RESTful principles), atunci in aplicatia noastra, aceste verbe nu trebuie sa aduca nicio modificare asupra bazei de date sau a server-ului
-toate verbele in afara de POST trebuie sa fie idempotente
-idempotente = de cate ori faci acelasi request catre server, acelasi raspuns vei primi
.practic, daca faci un request sau N request-uri => tot acelasi raspuns vei primi de la server
-nu se garanteaza idempotenta, dar daca aderam la principiile REST, atunci in aplicatia noastra GET, HEAD, PUT si DELETE trebuie folosite in asa maniera incat de fiecare data si ori de cate ori sunt apelate, ele sa returneze acelasi raspuns de la server
-POST nu este nici safe nici idempotent => aduce modificari asupra bazei de date si de asemenea "notes" se va modifica la fiecare adaugare de un nou "note", adica vei primi alt raspuns la fiecare folosire de POST

Middleware
--------------------
-json-parser este un middleware
-middleware = functie care poate fi folosita pentru a trata obiectele "request" si "response"
.middleware = functie folosita pentru a trata raspunsul de la server si catre server
-functiile sunt apelate in ordinea in care sunt scrise, adica in ordinea in care folosim metoda "app.use()" cu ele => "unknownEndpoint" trebuie folosit cu use() la sfarsit doar, inainte de a incepe sa facem bind intre port si web-server
-de exemplu, json-parser trebuie folosit inainte de a folosi "requestLogger" pentru ca altfel nu se initializeaza proprietate "body" din obiectul "request" => "requestLogger" nu are ce sa afiseze in consola
-de regula, un middleware ia 3 parametri:
const requestLogger = (request, response, next) => {
	console.log('Method:', request.method);
	console.log('Path:  ', request.path);
	console.log('Body:  ', request.body);
	console.log('---');
	next();
}
-prin "next()" din ultima linie se da control urmatorului middleware din pipeline
.practic, in parametrul "next" este primita o functie care va fi apelata pentru a trece la urmatorul middleware din pipeline
-daca vrem ca middleware sa se apeleze inainte de event handler-ele pentru rute, trebuie sa le folosim cu "use()" inainte de a defini rutele
.putem folosi middleware si dupa ce am definit rutele, dar practic asta inseamna ca ele vor fi apelate doar daca nu avem route specificate pentru a trata un anumit request
.de exemplu, "unknownEndpoint", care trateaza request-uri trimise la adrese URL care nu exista
-de aceea, "unknownEndpoint" este ultimul, pentru ca de regula, astfel de middleware se definesc dupa ce am definit rutele (adrese URL care chiar exista) si in caz ca utilizatorul foloseste una nespecificata si incorecta, atunci sa ii putem trimite un status code 404
-aveam un bug in care nu se afisau "notes" adaugate pentru ca nu atribuiam rezultatul in variabila "notes" astfel...
notes = notes.concat(note);
...ci doar puneam "notes.concat(note);" fara sa actualizez pe "notes"

Exercises 3.7-3.8
--------------------
-se continua "Phonebook backend"
-(?)

b. Deploying app to internet
----------------------------------------
-am preluat din (part2, e) si am folosit "npm install" ca sa instalez dependintele pentru React
-am schimbat "baseURL"

Same origin policy and CORS
--------------------
-CORS = Cross-Origin Resource Sharing
-desi putem accesa "http://localhost:3001/api/notes", partea de backend, din browser sau Postman, nu o putem accesa din frontend, din React, pentru ca primim eroarea: "Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at http://localhost:3001/api/notes. (Reason: CORS request did not succeed)."
-React = frontend = la portul 3000
-backend = la portul 3001
-putem accesa direct din browser adresa "http://localhost:3001/api/notes", dar nu o putem accesa din intermediul aplicatiei noastre, care este pe portul 3000
-deoarece aplicatia este pe portul 3000 si server-ul este pe portul 3001 => nu au aceeasi origine => cele 2 nu pot comunica
.nu pot comunica, pentru ca default este ca o aplicatie JavaScript ce ruleaza in browser poate comunica cu un server cu care imparte aceeasi origine
-scheme/host/port = daca toate acestea 3 coincid => atunci, despre 2 URL-uri se spune ca au aceeasi origine
-pentru a permite request-uri de la alte origini, instalam middleware "cors" in backend...
npm install cors --save
...si instructiunea in index.js din backend:
app.use(cors())
-dadea eroare cu "Module not found" pentru cors pentru ca il instalasem in frontend si trebuia in backend

Application to the Internet
--------------------
-o aplicatie basic in Heroku se face cu "heroku create"
-aplicatia se pune pe Heroku cu "git push heroku master"
-in Heroku, un fisier "Procfile", simplu, fara extensie, in folder-ul radacina, ii spune cum sa porneasca aplicatia, la noi prin "web: node index.js"
-vom defini o "environment variable" pentru PORT sau folosim 3001 daca nu se gaseste, in index.js
-cu comanda "heroku logs -t", Heroku printeaza logs in consola
-daca am scris cod in alt branch decat "master", folosim "git push heroku HEAD:master" sau "git push heroku HEAD:master --force"
-am pus server-ul (backend) pe Heroku la "https://a3drian.herokuapp.com/api/notes/"

Frontend production build
--------------------
-aici vom pune aplicatia React pe Internet
-cand React e in development mode, printeaza erori in consola, da refresh la browser la orice modificare, etc => daca vrem sa facem deploy => production build version of the application
-versiunea de productie se face cu "npm run build" in folder-ul radacina al aplicatiei
-dupa rularea "npm run build" se creeaza un folder "build"
-in "build" avem un singur fisier .html (index.html) si directorul "static"
-in "static" sunt salvate bucatile de cod JavaScript, care insumate => aplicatia React => toate bucatile de cod insumate, impreuna cu tot codul din dependintele proiectului => minimizat intr-un singur fisier => acel singur fisier = aplicatia noastra React

Serving static files from the backend
--------------------
-putem copia acest folder "build" in folder-ul radacina din repo "a3drian" de pe Heroku si apoi sa configuram backend astfel incat sa afiseze pagina principala din frontend, acel "build/index.html", cu pasii de mai jos
-pentru ca "express" sa afiseze continut static, adica fisierele din folder-ul "static" (cod JavaScript, dar si index.html, de exemplu) al aplicatiei, avem nevoie de middleware "static"...
npm i static -s
...pe care il folosim:
app.use(express.static('build'))
-acum, daca "express" primeste un GET request, mai intai cauta daca exista un asemenea fisier in "build" si daca il gaseste, il afiseaza
-mai mult, request-uri la "/index.html" sau direct la "/" => tratate de frontend
-request-uri la "/api/notes" => tratate de frontend
-deoarece frontend si backend se afla la aceeasi adresa "https://a3drian.herokuapp.com", putem folosi o cale relativa (relative path) pentru "baseURL":
const baseUrl = '/api/notes'
-acum, aplicatia este vizibila de la adresa de backend, adica de la portul 3001
.aplicatia functioneaza ca un "single-page-app", cum am vazut la inceputul cursului (part 0)
-in fisierul "index.html" din "build", avem o instructiune care cere sa se aduca un .css si 2 instructiuni care sa ceara codul JavaScript al aplicatiei, al aplicatiei React propriu-zise
-aplicatia aduce "notes" de la "http://localhost:3001/api/notes" si le afiseaza pe ecran, vezi 29ea.png si "Network" in consola

Streamlining deploying of the frontend
--------------------
-vom pune...
"build:ui": "rm -rf build && cd ../../osa2/materiaali/notes-new && npm run build --prod && cp -r build ../../../osa3/notes-backend/",
"deploy": "git push heroku master",
"deploy:full": "npm run build:ui && git add . && git commit -m uibuild && npm run deploy",    
"logs:prod": "heroku logs --tail"
...in package.json pentru backend, sub "scripts"
-caile sunt relative si trebuie modificate pentru aplicatia noastra
npm run build:ui = construieste frontend si copiaza folder-ul "build" in folder-ul care contine backend
npm run deploy = face deploy pe Heroku
npm run logs:prod = afiseaza logs din Heroku
-am setat "bash.exe" ca sa execute script-uri npm astfel:
npm config set script-shell "C:\\Program Files\\git\\bin\\bash.exe"

Proxy
--------------------
-cand am schimbat adresa din variabila "baseURL" intr-una relativa, "api/notes", adresa va indica spre portul 3000, pentru ca pe portul 3000 este configurata aplicatia sa ruleze
.cu alte cuvinte, "api/notes" se transforma in "localhost:3000/api/notes" si nu mai indica la "localhost:3001/api/notes" unde este de fapt server-ul
-daca aplicatia a fost creata cu "create-react-app", putem adauga in package.json al aplicatiei React...
"proxy": "http://localhost:3001"
...iar in urma acestui script, aplicatia React in modul development va functiona ca un proxy
.proxy are effect doar cand esti in development mode cu aplicatia React, adica "npm start"
-pentru ca functioneaza ca un proxy, atunci cand aplicatia React face request-uri care nu tin de aplicatie, de exemplu alte instructiuni decat cele care aduc .css sau cele 2 instructiuni care sa ceara codul JavaScript al aplicatiei, catre adresa "localhost:3000", request-urile vor fi trimise catre server, server care exista la adresa "localhost:3001"
.cu alte cuvinte, orice request care nu tine de aplicatie, nu tine de cum arata aplicatia sau de logica, este trimis catre server
.practic, prin proxy, toate request-urile necunoscute in modul development vor fi trimise catre server-ul de la portul 3001
-acum, daca facem deploy pe Heroku, ar trebui ca in loc de "Hello, aditza" sa vedem exact index.html din frontend
.nu uitam sa actualizam index.js din backend
-felul in care noi punem aplicatia pe internet este cumbersome si este foarte dificil sa cream un "development pipeline" automat
-se poate face un deploy la frontend ca o aplicatie de sine statatoare, vezi:
https://github.com/mars/create-react-app-buildpack
-codul pentru aplicatie este in branch "3-3":
https://github.com/fullstack-hy2020/part3-notes-backend/blob/part3-3/
-e un mic bug, daca dai pe "important" iti zice ce "note" a fost deja stearsa de pe server, ca la GetAllFail(), unde intentionat aveam un "note" inexistent (?)

Exercises 3.9-3.11
--------------------
-se continua "Phonebook backend"
-(?)

c. Saving data to MongoDB
----------------------------------------
Debugging Node applications
--------------------
-folosind keyword "debugger;"
-in Command Prompt, poti folosi comanda "node --inspect index.js" si apoi deschide Chrome si "DevTools for Node.js"
.tot aici, in "Sources" poti pune break points, poti vedea valorile variabilelor, executa alt cod JavaScript si poti vedea mesajele scrise cu "console.log()"
-question everything = console.log, debugger, Postman, etc. peste toate, pentru ca de la toate pot aparea erori
-the "Andon Cord" from Toyota = stop and fix principle

MongoDB
--------------------
-Mongo nu este o baza de date relationala
-Mongo is a document database, a NoSQL database
-document database = toate informatiile despre o comanda sunt retinute intr-un singur loc
.nu mai ai tabelul "Clienti", "Adrese", "Produs", etc. => un singur loc contine toate datele despre o comanda
-Mongo documents:
-documentele sunt salvate sub forma BSON = binary JSON
-in documente se regasesc "field-and-value pairs":
{
	name: "adi",
	..
}
-field = name, value = "adi"
var mydoc = {
               _id: ObjectId("5099803df3f4948bd2f98391"),
               name: { first: "Alan", last: "Turing" },
               birth: new Date('Jun 23, 1912'),
               death: new Date('Jun 07, 1954'),
               contribs: [ "Turing machine", "Turing test", "Turingery" ],
               views : NumberLong(1250000)
            }
-"_id" = retine un bson-type ObjectId
-"_id" este rezervat pentru a fi folosit ca primary key => trebuie sa fie unic in colectia din care face parte documentul => daca nu este dat explicit, Mongo il creeaza
-"_id" este immutable si nu poate fi de tip array
-"name" = retine un "embedded document", care are ca "field": "name" si "last"
-restul sunt self-explanatory
-daca vrem sa ajungem la "Turingery" din field-ul "contribs" folosim comanda "contribs.2" => Mongo foloseste "dot notation" pentru a accesa values din fields
-Mongo collections:
-colectiile sunt analog tabelelor intr-o baza de date relationala, vezi Mongo-col1.png
-intr-o colectie intra mai multe documente, intr-o baza de date Mongo intra mai multe colectii
-o colectie poate fi creata explicit cu "createCollection()"
-MongoDB Atlas
-Database Access -> adrian, ZbURtGAc1OBAIbYN -> Read and write
-Network Access -> Allow access from anywhere
-Clusters -> Connect -> Connect your application => o adresa care reprezinta un MongoDB URI
-MongoDB URI e practic un connection string...
mongodb+srv://adrian:ZbURtGAc1OBAIbYN@cluster0.qyqtz.mongodb.net/test?retryWrites=true&w=majority
...pe care il vom folosi in mongo.js
.atentie, parola trebuie URL encoded ca sa functioneze, vezi https://docs.atlas.mongodb.com/troubleshoot-connection/#special-characters-in-connection-string-password
-prin "process.argv[2]" se acceseaza parametrii dati in linie de comanda
-daca rulam "npm mongo.js ZbURtGAc1OBAIbYN", se va salva un nou "note" in baza de date "test"
.o putem vedea in Clusters -> Collections
-am dat drop la "test" pentru ca am inlocuit-o cu "note-app"
-nu e necesara creearea de baza de date din GUI Mongo pentru ca se creeaza automat cand se insereaza in baza de date
-se poate accesa baza de date direct din cod JavaScript, dar se prefera modulul "mongoose":
npm i -g mongoose / npm install mongoose --save
-Mongoose = object document mapper = practic, salveaza obiecte JavaScript ca documente Mongo
-Mongoose este un modul care permite foarte usor aceasta salvarea de obiecte JavaScript ca documente Mongo

Schema
--------------------
.String is shorthand for {type: String}
-using a schema, we tell Mongoose how to store the "note" object in the database:
const noteSchema = new mongoose.Schema({
	content: String,
	date: Date,
	important: Boolean,
})
-we require three fields "content", "date" and "important" with String, Date and Boolean as value types
-cand se creeza modelul, se creaza cu metoda "model()" si o schema data (cea de mai sus)...
const Note = mongoose.model('Note', noteSchema)
..."'Note'" reprezinta numele la singular al modelului (Customer, Order, Product, etc.)
-in aceeasi colectie, Mongo permite salvarea de documente cu perechi field-value diferite pentru ca Mongo este schemaless
-totusi, prin Mongoose, putem defini o schema (o structura) la nivelul aplicatiei noastre care sa intareasca (reinforce) structura documentelor salvate (in orice colectie de date Mongo)

Creating and saving objects
--------------------
-se creeaza un obiect JavaScript folosind modelul "Note" definit mai sus:
const note = new Note({
	content: 'HTML is Easy',
	date: new Date(),
	important: false,
})
-modelului i se mai spune "constructor function" deoarece construiesc obiecte JavaScript folosind argumentele primite ca parametru, "content", "date", etc.
-deoarece am folosit mai sus metoda "model()" => avem si metoda "save()" cu care putem stoca in baza de date noua "note" creeata
-la metoda "save()" putem inlantui metoda "then()" cu care putem printa de exemplu in consola:
note.save().then(result => {
	console.log('note saved!')
	mongoose.connection.close()
})
-in acest "then()" putem inchide conexiunea catre baza de date
-este foarte importanta inchiderea conexiunii prin "mongoose.connection.close()"
-obiectul "result" poate fi printat for debugging purposes

Fetching objects from the database
--------------------
-deoarece am folosit mai sus metoda "model()" => avem si metoda "find()" cu care putem aduce toate "notes" din baza de date si le printa pe ecran:
Note.find({}).then(result => {
    result.forEach(note => {
        console.log(note)
    })
    mongoose.connection.close()
})
-deoarece parametrul lui find() este "{}" => nu s-a impus nicio filtrare asupra rezultatelor => se vor aduce si afisa toate "notes"
-putem filtra, de exemplu dupa field-ul "important", astfel:
Note.find({ important: true }).then(result => {..}

Exercise 3.12
--------------------
-se continua "Phonebook backend"
-(?)

Backend connected to a database
--------------------
-de data asta am folosit "nodemon index.js ZbURtGAc1OBAIbYN" pentru a porni server-ul pe portul 3001 si pentru a putea lua "notes" din baza de date
-aplicatia presupune ca exista in toate documentele din colectie un id unic, la noi este reprezentat de field-ul "_id"
-desi "_id" arata ca un String, este de fapt un Object
-pentru a formata obiectele returnate de Mongoose, putem modifica metoda "toJSON":
noteSchema.set('toJSON', {
	transform: (document, returnedObject) => {
		returnedObject.id = returnedObject._id.toString()
		delete returnedObject._id
		delete returnedObject.__v
	}
})
-se observa ca nu vom mai afisa field-urile "_id" si "__v"
-se observa ca am folosit explicit "toString()" pe "_id" pentru a ne asigura ca nu vom avea probleme la unit testare
-se mai observa ca se pot adauga fields on-the-fly, de exemplu, am scos field-ul "_id" si l-am inlocuit cu field-ul "id" (fara "_" in fata)
-acum, "notes" devine un array de obiecte returnate de Mongo
-prin metoda "toJSON" din Mongo se apeleaza automat "JSON.stringify"

Database configuration into its own module
--------------------
-vom extrage codul pentru modulul Mongoose in fisier separat
-modul de a defini module Node este diferit de modul de a defini module JavaScript (ES6)
-interfata exportata prin "module.exports" este singura vizibila in afara fisierului "note.js"
-interfata va fi modelul "Note" pe care l-am tot folosit pana acum pentru a defini structura in baza de date a unei "note"
-vom crea environment variable "MONGODB_URI"
-vom folosi modulul "dotenv", care trebuie sa fie importat inainte de a importa modelul de "note", pentru a stabili variabilele de mediu (environment variables):
npm install dotenv --save
-se creeaza un fisier ".env" in folder-ul radacina in care punem String-ul de conexiune si portul
-importul pentru fisierul ".env" se face in "index.js", nu in modelul de "note":
require('dotenv').config();

Using database in route handlers
--------------------
-pentru a crea un nou "note":
app.post('/api/notes', (request, response) => {
    const body = request.body;

    if (body.content === undefined) {
        return response.status(400).json({
            error: 'content missing'
        })
    }

    const note = new Note({
        content: body.content,
        important: body.important || false,
        date: new Date(),
    })

    note.save().then(savedNote => {
        response.json(savedNote)
    })
})
-folosim constructor function "new Note(..)" pentru a crea un obiect nou "const note" care este de tip model Mongo => avem functia save()
-deoarece am trimis raspunsul ca un callback inauntrul functiei save(), atunci ne-am asigurat ca raspunsul a fost trimis numai dupa ce operatia s-a terminat cu succes
-"savedNote" este noul "note" creat si salvat in baza de date
.il vom trimite ca raspuns cu "response.json(savedNote);"
-acum daca vrem sa cautam dupa un id anume, trebuie sa folosim id-ul din baza de date 
"api/notes/5f28300c628292059852d4de/", in loc de "api/notes/2"
-cand se foloseste "dotenv" se prefera folosirea "Preload" daca mergem pe "import" si nu "require", vezi: https://www.npmjs.com/package/dotenv

Verifying frontend and backend integration
--------------------
-se recomanda testarea backend cu browser-ul, Postman sau REST Client pentru VSC
-se recomanda implementarea lui GET => testare backend => testare backend prin frontend
-se recomanda implementarea altor functionalitati => testare backend => testare backend prin frontend => etc.
-putem folosi "mongo.js" pentru a verifica faptul ca datele persista in baza de date
-[BUGS]:
-ori aveam o problema cu faptul ca aveam cod pentru conectare la baza de date de doua ori
-ori era problema in fisierul ".env" ca am pus ' in loc de `
-ori am pus ; in ".env" fara sa imi dau seama
-ori nu era interpolat calumea string-ul de conexiune
-ori am pus ' sau ` in ".env" si trebuia sa pun direct:
MONGODB_URI=mongodb+srv://adrian:ZbURtGAc1OBAIbYN@cluster0.qyqtz.mongodb.net/note-app?retryWrites=true&w=majority

Exercises 3.13-3.14
--------------------
-se continua "Phonebook backend"
-(?)

Error handling
--------------------
-daca se da un "id" invalid => response este "null"
-de aceea, vom modifica request-ul GET astfel incat sa intoarca un status code 404 daca nu gaseste acel "id" si sa prindem erori cu catch() daca promisiunea returnata de metoda "findById()" are valoarea de "rejected":
-este important sa incheiem raspunsul cu "end()" sa nu ramana browser-ul in hanging daca nu gaseste acel "id"
-daca nu se gaseste => 404 NOT FOUND
-daca apare eroare si promisiunea nu se intoarce cu "fulfilled" => 500 SERVER ERROR
-cand folosim "send()", Express presupune ca vrei sa trimiti un String => va seta Content-Type la "text/html", spre deosebire de "end()" care doar cheama functia de terminare a raspunsului
-mai trebuie tratat cazul in care se face un request cu un "id" care nu este formatat corespunzator: "http://localhost:3001/api/notes/2", sau "http://localhost:3001/api/notes/someInvalidId", etc. in loc de "http://localhost:3001/api/notes/5c41c90e84d891c15dfa3431" => 400 BAD REQUEST
-status code 400 = server-ul nu intelege request-ul pentru ca "malformed syntax"
-cand se lucreaza cu promisiuni, este o idee buna sa introducem tratare de erori si sa printam in consola eroarea deoarece se poate intra pe ramura de tratarea erorilor din forte multe situatii => este important sa faci logging in consola si sa ai consola mereu deschisa

Moving error handling into middleware
--------------------
-error handler-ele, ca middleware, din Express incep cu 4 parametri...
const errorHandler = (error, request, response, next) => {..}
...primul dintre care este un parametru de tip Error
-"Sentry" este un error tracking system care poate fi folosit daca implementam tratarile de erori intr-un singur loc, intr-un singur middleware
-vom modifica functiile care au blocul catch() astfel incat sa preia eroarea si sa o dea mai departe prin next():
.catch(error => next(error))
-deoarece am folosit next(error), vor fi preluate de acel middleware care are ca prim parametru unul de tip Error, exact acel "errorHandler" de mai sus
.daca next() este apelata fara parametru => executia merge la urmatorul middleware
.daca next(error) este apelata cu parametru => executia merge la middleware care face tratarea erorilor (error handling)
-daca vrem sa folosim "next()" in interiorul unei functii, nu uitam sa actualizam antetul acelei functii astfel...
app.get('/api/notes/:id', (request, response, next) => {
...adica sa include si pe "next" intre parametri

The order of middleware loading
--------------------
-"json-parser" ar trebui sa fie printre primele middleware cu "use()", deoarece:
.nu am putea folosi middleware de "logging" pentru ca proprietatea "body" a obiectului "request" ar fi goala
-middleware de "unknown endpoint" ar trebui pus chiar inainte de cel de "error handling":
.daca "unknown endpoint" ar fi pus inainte de a defini rutele, "api/notes", etc., atunci toate request-urile ar fi tratate ca un "unknown endpoint", deoarece acest "unknown endpoint" raspunde la toate request-urile cu status code 404 => nicio alta ruta sau middleware nu va mai fi apelata in continuare
.singura exceptie este daca ar aparea o eroare => s-ar executa "error handling" middleware

Other operations
--------------------
-pentru a sterge, folosim "findByIdAndRemove()"
-putem avea cazul in care stergem un "note" care exista (valid) si unul care nu exista => pentru ambele vom folosi status code 204 NO CONTENT:
app.delete('/api/notes/:id', (request, response, next) => {
    Note.findByIdAndRemove(request.params.id)
        .then(result => {
            response.status(204).end()
        })
        .catch(error =>
            next(error))
})
-acel "result" poate fi folosit pentru a verifica faptul ca intr-adevar s-a sters o "note" => ne permite sa verificam daca a fost sters un "note" valid sau invalid => daca s-a sters un "note" invalid => facem tratarea cazului respectiv in mod separat
-pentru actualizare proprietatii "important", folosim "findByIdAndUpdate()"
-de data asta folosim PUT in loc de POST:
app.put('/api/notes/:id', (request, response, next) => {
    const body = request.body

    const note = {
        content: body.content,
        important: body.important,
    }

    Note.findByIdAndUpdate(request.params.id, note, { new: true })
        .then(updatedNote => {
            response.json(updatedNote)
        })
        .catch(error => next(error))
})
-"findByIdAndUpdate()" primeste ca parametru un obiect JavaScript si nu obiect construit cu function constructor "Note" (ala pe care il foloseam ca model pentru Mongoose)
-prin "{new: true}", fortam handler-ul sa foloseasca obiectul "note" creat in interiorul functie de update si nu pe cel original
-prin acest obiect "note" ne referim la parametrul "updatedNote" din then()
.default, "updatedNote" va fi documentul original, extras din colectie, fara modificari
.noi ii spunem sa foloseasca acel obiect "note" si nu documentul original
-pentru a elimina eroarea care spune ca "findByIdAndUpdate" e deprecated, folosim in modelul de "note.js":
mongoose.set('useFindAndModify', false)
-[BUGS]:
-am comentat route care facea POST atunci cand am facut verbul PUT
.cu alte cuvinte, daca da un 404 cand folosesti un verb s-ar putea sa nu se fi definit ruta respectiva pentru verbul respectiv
-add DELETE button (?)

Exercises 3.15-3.18
--------------------
-se continua "Phonebook backend"
-(?)

d. Validation and ESLint
----------------------------------------
-se poate observa ca fara a face validare pe continutul unui "note" => 400 BAD REQUEST
-pentru POST, verificam daca "note" contine text, adica sa nu fie un "note" gol cu...
if (body.content === undefined) {
	return response.status(400).json({
		error: 'content missing'
	})
}
...dar se poate face aceeasi verificare folosind "Schema" din Mongoose:
const noteSchema = new mongoose.Schema({
    content: {
        type: String,
        minlength: 5,
        required: true
    },
    date: {
        type: Date,
        required: true
    },
    important: Boolean
})
-"content" si "date" sunt acum obligatorii, iar "content" trebuie sa aiba o lungime de minim 5 caractere
-folosind "Schema" din Mongoose putem face verificarea inainte ca datele sa fie salvate in baza de date
-"minlength" si "required" sunt validators built-in Mongoose, dar se pot defini si altele personalizate daca e nevoie
-daca incercam sa trimitem un "note" care nu respecta noile constrangeri => exceptie => vom folosi acel "errorHandler" de mai devreme apeland functia next() cu parametrul error
.de asemenea, trebuie sa actualizam antetul functiei POST sa includa parametrul "next"
.de asemenea, actualizam "errorHandler" sa trateze erori de tip "ValidationError":
if (error.name === 'ValidationError') {..}

Promise chaining
--------------------
-inainte foloseam metoda "toJSON()" pentru a ne asigura ca datele sunt in formatul corect...
note.save()
	.then(savedNote => {
		response.json(savedNote.toJSON())
	})
...dar putem folosi "promise chaining" pentru a obtine aceeasi functionalitate:
note.save()
	.then(savedNote => {
		return savedNote.toJSON()
	})
	.then(savedAndFormattedNote => {
		response.json(savedAndFormattedNote)
	})
-primul "then()" primeste pe "savedNote" care este returnat din baza de date de Mongoose si este formatat folosind "toJSON()"
-deoarece primul "then()" returneaza o promisiune, putem accesa acel "savedNote" care a fost deja formatat prin parametrul "savedAndFormattedNote"
.pentru ca "then()" a unei promisiuni returneaza tot o promisiune
-daca folosim sintaxa scurta, codul devine:
note.save()
	.then(savedNote => savedNote.toJSON())
	.then(savedAndFormattedNote => {
		response.json(savedAndFormattedNote)
	})
-"promise chaining" este extrem de folositor in cazul in care avem nevoie de mai multe operatii asincrone pe care le avem de executat in ordine, cum e mai sus: mai intai formatam datele din baza de date in primul "then()" si apoi le trimitem ca raspuns in al doilea "then()"

Deploying the database backend to production
--------------------
-folosim comanda...
heroku config:set MONGODB_URI=mongodb+srv://adrian:ZbURtGAc1OBAIbYN@cluster0.qyqtz.mongodb.net/note-app?retryWrites=true&w=majority
...vom defini pentru folosirea ei in "production mode"
.pana acum, MONGODB_URI era un environment variable folosit doar in "development mode"
-daca nu merge comanda, merge pus String-ul de conexiune intre ''

Exercises 3.19-3.21
--------------------
-se continua "Phonebook backend"
-(?)

Lint
--------------------
-se instaleaza pachetul ESlint cu...
npm install eslint --save-dev
...si se initializeaza fisierul de configurare ".eslintrc.js" cu:
eslint --init
.e posibil sa trebuiasca sa navigam in folder-ul "node_modules/.bin" si de acolo sa rulam comanda "eslint --lint", vezi lint-1.png
-tot in "node_modules/.bin" se va regasi si fisierul de configurare ".eslintrc.js"
-"linting" = analiza statica a codului = poate verifica inclusiv reguli de stil, '' in loc de "" pentru String-uri, folosirea de Tab in loc de Space pentru indentation, etc.
-daca se adauga...
"lint": "eslint ."
...sub "scripts" in package.json, atunci putem rula comanda "npm run lint" pentru a verifica toate fisierele din intregul proiect
-lint are si el un "gitignore", numit ".eslintignore"
-punem acolo "build" pentru ca nu vrem sa se aplice regulile de lint in folder-ul de "build"
.am adaugat de asemenea folder-ul "front_end" pentru a evita conflictul cu package.json din frontend
-in linia "eslint:recommended" inseamna ca fisierul nostru de configurare vine preincarcat cu anumite reguli, pe care le putem suprascrie
-de exemplu, vom suprascrie...
'no-console': 0
...pentru a nu mai afisa avertismente legate de comenzile "console.log()"
-cu 'eqeqeq': 'error' se verifica daca facem comparatii de egalitate strict cu "==="
-daca aduci modificari asupra ".eslintrc.js", e mai bine sa il testezi cu "npm run lint" pentru a verifica daca este formatat corect ca fisier JSON
-se poate folosi VS Code ESlint plugin (?)
npm i eslint -g

ex_d:
-in Delete(), promisiunea nu mai intoarce nimic de la server

Exercise 3.22
--------------------
-se continua "Phonebook backend"
-(?)

--------------------Part 2, Communicating with server--------------------

a. Rendering a collection, modules
----------------------------------------
console.log
--------------------
-separate things to be printed with a comma, ca in Python:
console.log('props:', props);
-daca folosesti "+" in loc de "," in consola apare ceva de genul "props: [Object object]" which is pretty useless

Protip: Visual Studio Code snippets
--------------------
-how to create snippets:
https://code.visualstudio.com/docs/editor/userdefinedsnippets#_creating-your-own-snippets
-am instalat extensia de aici:
https://marketplace.visualstudio.com/items?itemName=xabikos.ReactSnippets

JavaScript Arrays
--------------------
-vom folosi find(), filter(), map()

Functional Programming in JavaScript pe YouTube
--------------------
Higher-order functions - Part 1 of Functional Programming in JavaScript
(https://www.youtube.com/watch?v=BMUiFMZr7vk&list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&index=1)
-permit scrierea de cod mai reutilizabil
-functions are values
-practic, poti crea o functie si sa o atribui unei variabile
-de asemenea, poti sa trimiti o functie ca parametru unei alte functii => higher-order function
-composition = pui o functie ca parametru unei alte functii apoi acea functie ca parametru unei alte functii, etc.
-filter() primeste ca parametru o alta functie => higher-order function
-filter() permite filtrarea intr-un array:
let animals = [
{ 	name: 'Hamilton', species: 'dog' },
{	.. }
]
var dogs = animals.filter(function(animal) {
	return animal.species === 'dog'
})
-se observa ca filter() a primit ca parametru un anonymous function
-acea anonymous function e un callback pentru ca functia gazda (host) va apela (call) aceasta functie anonima
-filter() itereaza prin array, deci e practic ca un for() peste care impui un filtru
-functia anonima poate fi atribuita unei variabile:
let isDog = function(animal) {
	return animal.species === 'dog'
}
-oarecum opusul lui filter() este reject()
-cu "nodemon" se deschide un server, trebuie sa folosim "node index.js" sa rulam fisierul

Map - Part 2 of Functional Programming in JavaScript
(https://www.youtube.com/watch?v=bCqtb-Z5YGQ&list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&index=2)
-daca inainte creeam functia anonima care sa returneze true sau false, acum returnam ca sa includa in array:
let names = animals.map(function(animal) {
	return animal.name
})
-aici nu mai comparam "animal === 'dog'" ci ii spunem lui map() sa include numele animalului
-cu arrow functions codul devine:
let names = animals.map((animal) => animal.name);

Reduce basics - Part 3 of Functional Programming in JavaScript
(https://www.youtube.com/watch?v=Wl98eZpkp-c&list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&index=3)
-find() face acelasi lucru cu filter() dar returneaza doar primul element care se potriveste criteriului de cautare
-reduce() se foloseste astfel:
let totalAmount = orders.reduce(function(sum, order) {
	return sum + order.amount
}, 0);
-"sum" incepe de la 0 pentru ca asa a fost definita functia de callback pentru reduce()
-"order" sau array-ul in care se face filtrarea se pune ca al doilea parametru
-practic "order" este pe rand cate un element din "orders", cam cum e la foreach()
-reduce() este o functie care permite scrirea de cod general, practic poate face acelasi lucru cu find(), filter(), map() si reject()

Reduce Advanced - Part 4 of Functional Programming in JavaScript
(https://www.youtube.com/watch?v=1DMolJ2FrNY&list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&index=4)
-redenumisem fisierul si cand dadeam "node index.js" zicea "MODULE NOT FOUND"
-nu a mers...
import fs from 'fs';
...dar a mers:
const fs = require('fs');
-uitasem sa pun "return customers" si atunci urmatorul obiect peste care itera era "undefined" => nu puteam extrage proprietati dintr-un obiect undefined
-reduce poate incepe de la o valoare, 0 cum era in exemplu cu suma, sau de la un obiect gol:
.reduce((customers, line) => {
        console.log(customers)
        customers[line[0]] = customers[line[0]] || []
        customers[line[0]].push({
            name: line[1],
            price: line[2],
            qty: line[3]
        })
        return customers;
    }, {});
-se observa "{}" de la sfarsit

Currying - Part 6 of Functional Programming in JavaScript
(https://www.youtube.com/watch?v=iZLP4qOwY8I&list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&index=6)
let dragon =
	name =>
		size =>
			element =>
				name + ' is a ' +
				size + ' dragon that breathes ' +
				element + '!'
let output = dragon('Karo')('large')('ice')
console.log(output)
-dragon() = a currying function
-it's basically a function that returns a function that returns a function until it returns an actual value
-we call dragon() with "Karo" which will return a function which will be called with "large" which will return a function which will be called with "ice" which will finally return an actual value which is a String
-"Karo" would be the "name" parameter, "large" would be the "size" parameter and "ice" would be the "element" parameter
-function currying allows modularity and reusability because it allows functions to be easily chained together
-modularity because at any one time you can replace the a function within a chain with a new, improved / different one

Event handlers revisited
--------------------
-event handler nu este o functie, ci este o atribuire de valoare
-practic asta inseamna ca in "onClick" trebuie sa atribui ca valoare o functie care sa faca ceva atunci cand se declanseaza evenimentul apasarii pe buton
-vezi correct-use-of-passing-event-handlers.png

Rendering collections
--------------------
-cu...
notes.map(note => <li>{note.content}</li>)
...obtinem...
[
  <li>HTML is easy</li>,
  <li>Browser can execute only JavaScript</li>,
  <li>GET and POST are the most important methods of HTTP protocol</li>,
]
...ceea ce inseamna ca "{note.content}" poate fi inclus intr-un element <ul>:
<ul>
	{notes.map(note => <li>{note.content}</li>)}
</ul>
-astfel, am scapat de hardcode-area indicilor elementelor din notes

Key-attribute
--------------------
-React suporta atributul "key" pe elementul <li>, vezi https://reactjs.org/docs/reconciliation.html#recursing-on-children
-aceasta "key" poate fi o componenta a datelor cu care vrei sa populezi lista, eg. exista deja in datele noastre un camp care poate fi folosit ca "key"
-tot ce trebuie sa facem noi este sa atribuim acest camp lui "key":
<li key={note.id}>
-astfel, se rezolva si eroarea "Each child in a list should have a unique "key" prop." din consola

Map
--------------------
-map() mereu creeaza un nou array
-acest nou array este creat din campuri ale array-ului original, eg. dintr-un array cu nume si varsta, cream un array doar cu nume

Anti-pattern: array indexes as keys
--------------------
-poti lua indicele din array si sa il folosesti ca "key":
notes.map((note, i) => ...)
<li key={i}>
..
-cand map() este apealat in acest fel, acelui "i" i se va atribui index-ul din array al elementului
-nu se folosesc indicii din array ca "key" in <li>, pentru ca poate afisa datele eronat, vezi https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318
-practic, fiecare din elementele din array trebuie sa aiba un "key" unic si permanent
-daca se folosesc indici, nu este permanent pentru ca scoti un element din lista, dar indicele nu este "scos" => in locul acelui indice se afiseaza un alt element decat cel dorit
-anti-pattern = atunci cand nu folosesti rezultatul unui functii de genul map(), care returneaza un array nou

Refactoring modules
--------------------
-se observa ca nu numai elementul <li> are nevoie de un "key":
<Note key={note.id} note={note} />
-practic, "key" se defineste pentru componente React pentru ca React sa stie in ce ordine sa re-randeze elementele daca este nevoie, eg. cand se sterge un element din lista sau cand trebuie sa concateneze DOM trees, vezi tot https://reactjs.org/docs/reconciliation.html#recursing-on-children
-dadea o eroare ciudata ca "note is undefined", referindu-se la apelul din...
<Note key={note.id} note={note} />
...ca si cum "note" din "note={note}" nu este numele exact din componenta React
-daca puneam numele corect atunci aplicatia ramanea hanging (?)
-componentele se pun in fisiere separate cu .js, se exporta componenta si se importa in index.js
-chiar si App() poate fi pus in App.js
-cand se cloneaza un proiect, se da mai intai "npm install" inainte de "npm start"

When the application breaks
--------------------
-e mai bine sa definesti componente pe mai multe linii, ca sa poti pune mai multe instructiuni, inclusiv un console.log() daca este cazul
-de asemenea, e bine sa folosim instructiunea return(<div>..</div>)
-mai mult, e mai simplu de folosit "(props)" in loc de varianta despachetata "({notes})" pentru ca nu stim exact ce este continut in "props"

Exercises 2.1-2.5
--------------------
-se continua exercitiile 1.1-1.5
-(?)

b. Forms
----------------------------------------
-se initializeaza "notes" ce vor fi afisate pe ecran in App()...
const [notes, setNotes] = useState(props.notes)
...si se initializeaza cu "props.notes" primite ca parametru, deci nu cu un array gol
-am adaugat pe evenimentul "onSubmit" ce functie callback sa fie apelata (call, invocata) atunci cand se apasa butonul de save:
<form onSubmit={addNote}>
-prin "event.preventDefault()" se evita comportamentul default atunci cand se apasa save
.in loc sa se reincarce pagina, evitam acest lucru prin preventDefault()
-prin "event.target" se afiseaza elementul HTML legat de evenimentul primit ca parametru, in cazul nostru este elementul de tip <form> mentionat mai sus:
const AddNote = (event) => {
    event.preventDefault()
    console.log('AddNote() button clicked', event.target)
}
-folosind "controlled components" putem accesa informatiile trimise prin elementul <form>, vezi https://reactjs.org/docs/forms.html#controlled-components
-"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`"
-controlled component = cand starea componentei App (sau a unei componente React) se defineste comportamentul unui element
.de exemplu, avem acest <form> al carui element <input> primeste ca atribut value o componenta React care are definita o stare:
const [newNote, setNewNote] = useState(
	'Insert a new note...'
)
.mai jos, avem:
<form onSubmit={AddNote}>
	<input value={newNote} />
	..
-deci avem o componenta React, newNote careia i se poate schimba starea pentru ca am folosit useState si am definit functia setNewNote() pentru ea
-de asemenea, am folosit aceasta componenta React pentru a modifica direct (controleaza) comportamentul acelui element <input> din <form>
.din aceste doua actiuni => am definit un "controlled component"
-"HandleNoteChange" a trebuit sa fie definita in App() pentru a recunoaste functia setNewNote()
-"event.target.value" se refera la exact continutul campului din <form>
-acum, "event.target" nu se mai refera la <form> ci la <input>:
const HandleNoteChange = (event) => {
	console.log('HandleNoteChange()', event.target)
	console.log('HandleNoteChange()', event.target.value)
	setNewNote(event.target.value)
}
.e si logic pentru ca am creat un event handler separat pentru <form> si unul separat pentru <input>
-in tabul "Components" din React Developer Tools, sub "hooks" se poate vedea continutul din <input> pe masura ce scrii in el
-continutul pe care il punem in obiectul "noteObject" este practic starea lui "newNote" de mai sus
.prin continut se intelege ce bagam in <form>
-reamintim ca nu se modifica in mod direct "starea" unui obiect, de aceea folosim .concat() pentru ca functia va returna un array nou
-de retinut ca starea unei componenta poate fi vazuta live din "hooks" sub "Components"

Filtering displayed elements
--------------------
-cand vine vorba de comparatii se foloseste "===" pentru a compara si tipul obiectelor
-daca punem "setShowAll(!showAll)", la fiecare click se face toggle intre a arata toate "notes" sau doar cele importante
-prin "show {showAll ? 'important' : 'all' } notes" se schimba ce se afiseaza in textul butonului: "show all notes" sau "show important notes"

Exercises 2.6-2.10
--------------------
-se creeaza "Phone book app"
-(?)

c. Getting data from server
----------------------------------------
-poti folosi un server JSON prin modulul "json-server":
npm install -g json-server
-daca vrem sa lucram cu o instalare locala trebuie sa includem "npx":
npx json-server --port 3001 --watch db.json
-intreaga baza de date, server-ul se va stoca in fisierul "db.json"

The browser as a runtime environment
--------------------
-daca se iau date cu XMLHttpRequest practic se face un request HTTP printr-un obiect XHR
-prin XHR nu se mai folosesc pentru ca s-au introdus metoda fetch() bazata pe promises
-JavaScript este construit pe modelul asincron
-operatiile IO, cu cateva exceptii, se executa "non-blocking" adica nu blocheaza firul de executie pana la terminarea executiei => dupa apelul unei operatii IO, codul se executa mai departe => nu se asteapta terminarea executiei apelului operatiei IO
-cand in sfarsit se termina, se apeleaza acea functie care este inregistrata (registered) pentru a fi apelata atunci cand operatia IO s-a terminat, eg. acel callback
-pentru ca aplicatia in JavaScript ruleaza pe un singur fir este foarte important ca operatiile IO sau cele care dureaza mult timp sa se execute asincron => nu se blocheaza server-ul cat timp acele operatii se executa => nu se blocheaza browser-ul
-desi poti avea "web workers" care te ajuta sa scrii cod paralelizat, window-ul din browser este administrat de un singur thread
-mai multe la (https://www.youtube.com/watch?v=8aGhZQkoFbQ):
-cand oricare dintre web APIs termina de executat asincron, imping rezultatul in "Task queue" si nu direct in call stack
-event loop este cel care ia din coada si pune in stiva, daca aceasta este goala
-event loop este puntea intre stack, web APIs si task queue 3.png
-event loop pune pe stiva doar daca aceasta este goala, vezi 4.png
.de-aia la setTimeout() sa punea 0 ca parametru, sa-l trimita la web API si de acolo imediat in Task queue
-parametrul din setTimeout() este un minim, adica va rula dupa sa zicem minim 1 secunda
.e mai mult o indicatie, ca in C#, nu inseamna ca va rula la exact 1 secunda dupa apel
-browser-ul ar dori sa faca render in window la fiecare 60 de secunde sa zicem
-acele 60 de secunde depind de ce facem noi in JavaScript pentru ca "Render queue" este blocat de "Task queue" (Callback queue)
-daca nu face render atunci practic nu poti face nimic pe acea pagina, pentru ca totul este blocat pana la golirea stivei pentru ca abia la golirea stivei se poate re-randa pagina

npm
--------------------
-comenzile npm se dau in folder-ul in care exista package.json
npm install axios --save
-daca punem ca flag "-dev", atunci pachetul va fi instalat ca o development dependency, sub "devDependencies":
npm install json-server --save-dev
-daca sub "scripts" punem...
"server": "json-server -p3001 --watch db.json"
...atunci putem invoca "server" cu comanda "npm run server"
.de aia functioneaza "npm run start", pentru ca se uita in package.json si cauta script-ul de "start"
-diferenta dintre runtime si development, este ca modulul trebuie la runtime pentru ca aplicatia sa se execute corect
-daca modulul era development dependency atunci aplicatia poate functiona si fara ea si va fi folosita doar in modul development

Axios and promises
--------------------
-get() din Axios returneaza o promisiune
-promise:
.pending = valoarea de "fulfilled/resolved" sau "rejected" nu a fost inca atinsa, se afla inca in proces de determinare
.fulfilled/resolved = nu se afla in proces, determina de regula o operatie incheiata cu succes
.rejected = nu se afla in proces, determina o eroare care a impiedicat incheierea operatiunii cu sucess
-rezultatul unei promisiuni se afiseaza cu then() care este un event handler legat de promise:
promise.then(response => {
	console.log(response)
})
-in codul de mai sus, practic se umple "response" cu rezultatul request-ului, unde acest rezultat al request-ului este continut in promisiune
-acest rezultat contine datele, efectiv datele rezultate, status code, 200, 404, etc. si header-ele
-get() si then() se pot scrie mai succint:
axios.get('http://localhost:3001/notes').then(response => {
	const notes = response.data
	console.log(notes)
})
.se evita astfel salvarea request-ului intr-o variabila => se foloseste function chaining => se umple constanta "notes" cu rezultatul request-ului
-daca in header-ul request-ului se specifica "content-type: 'application/json; charset=utf-8'", atunci Axios poate interpreta raspunsul request-ului folosind un JavaScript array, de aia poti printa cu "console.log(response)"

Effect-hooks
--------------------
-used when fetching data from the server
-a trebuit sa pun "npm run start" (in loc de "npm start") sa porneasca din Command Prompt
-de regula, db.json se afla unde se afla si package.json
-axios.then() practic inseamna event handler pentru momentul in care "data" vine inapoi de la server
-get() face request-ul si then() se ocupa de raspunsul la request => then() = event handler
-aparent functiona ciudat cand am rulat "npm run start" din Command Prompt, rezulta o ordine diferita a blocului:
render 0 notes
effect
promise fulfilled
render 3 notes
-cand am rulat din Terminal din VSC a mers calumea
-mai intai, se afiseaza "render 0 notes" pentru ca datele nu au ajuns inapoi de la server
-imediat dupa primul render, se intra in functia "effect", se afiseaza "effect" si se face request-ul catre server
-cand primim raspuns reusit de la server, se intra in then() si se populeaza array-ul original "notes" cu datele din "response.data"
.de asemenea, se afiseaza "promise fulfilled"
-se afiseaza "render 3 notes" pentru ca a fost apelat "setNotes()" care este o functie care modifica starea variabilei "notes" => se re-randeaza componenta <App> => se afiseaza "render 3 notes"
-"setNotes()" este numita state-updating function
-o state-updating function determina re-randarea componentei React in care se afla
-cum se folosesc effect-hooks:
useEffect(effect_hook, []);
-useEffect() ia ca prim parametru un "effect-hook function"
-al doilea parametru specifica cand va fi folosit effect_hook
-de regula, un effect-hook function ruleaza la fiecare render complet, dar se poate specifica sa ruleze si altfel
.de exemplu, vrem sa rulam effect-hook function doar la primul render => specificam "[]" ca al doilea parametru in useEffect()

The development runtime environment
--------------------
-vezi 18e.png
-"react app" este codul JavaScript ce ruleaza in browser
-codul JavaScript este preluat din "react dev server"
-"dev server" este o aplicatie ce porneste dupa ce dam comanda "npm start"
-"dev server" transforma codul JavaScript intr-un cod ce poate fi interpretat de browser si de asemenea imbina codul scris in mai multe fisiere intr-unul singur
-datele din aplicatie sunt preluate din "json-server" care ruleaza pe portul 3001
-"json-server" preia datele din db.json
-se observa ca tot ce tine de aplicatie ruleaza pe masina locala, adica pe localhost

Exercises 2.11-2.14
--------------------
-se continua "Phone book app"
-(?)

d. Altering data in server
----------------------------------------
-REST = definesc o serie de constrangeri care trebuiesc indeplinite atunci cand creezi un serviciu web
-constrangerile (conventiile web) la https://en.wikipedia.org/wiki/Representational_state_transfer#Applied_to_Web_services
-daca un serviciu web se defineste ca fiind RESTful inseamna ca acesta poate interopera cu alte sisteme / servicii pe Internet

REST
--------------------
-vorbind de terminologia REST, "notes" = resursa
-individual data objects = resources, cu accent pe "data" => aceste obiecte trebuie sa contina date
-fiecare resursa are o adresa asociata, un URL, eg. "/notes"
-o singura "note" din "notes" ar trebui sa fie accesibila la URL-ul "/notes/3", unde 3 reprezinta id-ul acelei singure "note"
-cu un request HTTP GET se aduc datele de la server, deci daca facem un GET request la "/notes/3" vom primi inapoi "note" cu id-ul 3
-pentru a adauga un "note" vom face un request HTTP POST catre adresa "/notes"
-textul acestui nou "note" este continut in corpul request-ului (body of the request)
-daca vrem sa trimitem date catre json-server, acestea trebuie formatate ca un JSON si trebuie sa contina in header "application/json" la content-type

Sending Data to the Server
--------------------
-e mai bine sa lasi server-ul sa puna un id cand trimiti un nou "note", pentru ca server-ul genereaza un id potrivit in functie de resursele (individual data objects) ce se afla deja pe server
-in consola, sub "XHR POST" si "Request" vezi textul din noul "note"
.acolo apare si "Request Payload"
-se pot verifica header-ele din request-urile POST pentru corectitudinea operatiilor
-noul "note" nu este afisat pe ecran pentru ca nu am facut update la componenta <App>
-se observa ca acum concatenam datele primite ca raspuns...
setNotes(notes.concat(response.data));
...si nu datele din "noteObject":
setNotes(notes.concat(noteObject));
.tot aici, primeam eroare ca nu am specificat un "key" pentru noul "note"
-reamintim ca concat() nu modifica array-ul "notes" original, ci creeaza unul nou => nu modifica in mod direct starea obiectului "notes"
-e mai bine sa lasi server-ul sa puna un timestamp cand trimiti un nou "note", pentru a nu avea probleme daca ceasurile nu sunt sincronizate
-se poate folosi Postman pentru a face debug pe request-urile POST care merg catre server

Changing the importance of notes
--------------------
-am adaugat un buton pentru fiecare "note" sa o putem marca "important" sau "not important"
-prin "toggleImportanceOf(id)" avem doar un "console.log('importance of note 3 needs to be toggled')"
-daca vrem sa modificam un "note" de pe server avem doua optiuni:
.cu PUT = replaces the entire note
.cu PATCH = changes only some properties of the note
-"==" face mai mult decat "===" pentru ca "==" incearca sa faca si o conversie de tip, la tipul membrului stang
-vom modifica toggleImportanceOf(id) astfel:
const toggleImportangeOf = (id) => {
	console.log(`importance of ${id} needs to be toggled`);
	const url = `http://localhost:3001/notes/${id}`;
	const note = notes.find(n => n.id === id);
	const changedNote = {
		...note,
		important: !note.important
	}

	axios
		.put(url, changedNote)
		.then((response) => {
			setNotes(notes.map(
				note => note.id !== id ? note : response.data
			))
		});
}
.nu a mers sa fac un event handler separat pentru ca aveam nevoie de "id", "id" pe care il luam din request-ul facut de axios.put(..)
-"url" este unic pentru fiecare "note", in functie de id-ul pe care il are
-cu find(), se cauta acel "note" caruia i se potriveste id-ul cu cel pe care il apasam noi in browser si il salvam ca un obiect in "const note"
-actualizam "note" astfel:
.copiem mai intai continutul din vechea "note" prin "...note"
.schimbam proprietatea de "important"
.creeam un obiect nou numit "changedNote" in care se reflecta acesta schimbare a proprietatii "important"
-reamintim ca "...note" = object spread syntax = va copia toate proprietatile "note" intr-un nou obiect
-si reamintim ca nu modificam in mod direct starea componentei => vom folosi un nou obiect "changedNote" in care sa se reflecte schimbarea
-de retinut ca "changedNote" este un shallow copy => daca "note" continea referinte la alte obiecte => "changedNote" va contine aceleasi referinte
-folosind map() vom crea un nou array de "notes" in care se va suprascrie, in functie de id, acea "note" care a fost modificata
.adica vom copia continutul din vechiul array pana cand dam de acel id care ne intereseaza si atunci vom suprascrie pe vechiea "note" cu "changedNote"
-din nou, map() creeaza un array nou => nu va modifica starea in mod direct

Extracting communication with the backend into a separate module
--------------------
-fiecare dintre functiile din notes.js returneaza promises
-GetAll() e singura care nu are parametri
-trebuie sa folosesc Update() cu "id" si nu cu "url" ca parametru:
NoteService.Update(id, changedNote)
-folosind "response" primim inapoi intregul raspuns primit de la server: header-e, date, etc.
-pe noi ne intereseaza doar datele din "response.data" din intregul obiect "response" => in notes.js vom modifica functiile astfel incat sa nu mai returneze promises, dar sa returneze "response.data"
-metoda then() a unei promisiuni returneaza tot o promisiune
-some reference legat de promises si promises chaining:
https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/async%20%26%20performance/ch3.md

Cleaner syntax for defining object literals
--------------------
-mai jos, avem 2 metode echivalente de a defini un obiect:
const name = 'Leevi';
const age = 0;
const person = {
  name: name,
  age: age
};
const person = { name, age };
-"const person = { name, age }" merge, pentru ca proprietatile au acelasi nume cu variabila "const name" si "const age" definite mai sus
-aceasta noua sintaxa merge doar pentru ca proprietatile impart acelasi nume cu variabilele

Promises and errors
--------------------
-am modificat GetAll() pentru a returna o "note" care nu exista in server:
const GetAll = () => {
    const request = axios.get(baseURL)
    const nonExisting = {
        id: 10000,
        content: 'This note is not saved to server',
        date: '2019-05-30T17:30:31.098Z',
        important: true,
    }
    return request.then(response => response.data.concat(nonExisting))
}
-cand un request da fail => promise este "rejected"
-daca se face un request catre aceasta "note" => eroare 404 => NOT FOUND
-trebuie sa scriem cod care sa trateze situatia in care starea unei promise este "rejected"
-adaugam in metoda then() un callback, care sa trateze cazul in care primim o eroare (inseamna ca promise a fost "rejected")
-sau, in loc de callback, folosim un bloc catch():
..
.catch(error => {
	alert(`The note "${note.content}" was already deleted from the server.`);
	console.log('error:', error);
	setNotes(notes.filter(
		n => n.id !== id
	))
})
-blocul catch() se pune mai jos in promise chain
-blocul catch() este apelat doar daca undeva in promise chain a aparut o eroare si acea promise a devenit "rejected"
-nu se recomanda crearea de pop-up alerts in aplicatiile mai serioase
-cu filter() vom afisa toate "notes" mai putin aceea care nu exista efectiv pe server
.filter() returneaza un array nou, continand acele elemente din array-ul primit ca parametru, pentru care rezultatul expresiei logice este "true"
-la fiecare rulare va aparea acel "note" care nu exista pe server, dar va fi filtrata odata ce se apasa butonul de "important" pe ea

Exercises 2.15.-2.18
--------------------
-se continua "Phone book app"
-(?)

e. Adding styles to React apps
----------------------------------------
-"import './index.css'" merge pentru ca React vine deja cu un .css default
-regulile din CSS se compun din selectors si declarations:
h1 {
	color: green;
	font-style: italic;
}
-"h1" este selector si "color: green" e declaration
-e mai bine sa folosim "class selectors" pentru a nu selecta toate heading-urile de tip <h1>, de exemplu
-desi normal unui element ii poti adauga atributul "class", in "return(..)" dintr-o componenta React, se foloseste "className"

Improved error message
--------------------
-ar trebui sa definim initial pe "errorMessage" cu null ca sa nu apara un <div> gol sub <h1>:
const [errorMessage, setErrorMessage] = useState(null);
-cand se creeaza o noua componenta React, trebuie folosit "import React from 'react'" si trebuie sa exportam acea componenta pentru a putea fi folosita in alte fisiere

Inline styles
--------------------
-"inline styles" se refera la a atribuirea de cod care sa cosmetizez componentele React prin atributul "style":
const divStyle = {
	color: 'blue',
	backgroundImage: 'url(' + imgUrl + ')',
};
function HelloWorldComponent() {
	return <div style={divStyle}>Hello World!</div>;
}
-se observa ca are alta sintaxa fata de codul CSS si ca se foloseste camelCase in loc de kebab-case (cu "-")
-inline styles nu pot fi folosite direct cu "pseudo-clase"
-spre deosebire de scoala clasica in care se prefera separarea de cod HTML, de cod CSS si cod JavaScript, in React se doreste crearea de componente care sa fie utilizabile de sine statator
.de aceea, se permite includerea de cod care sa cosmetizeze componentele React pentru ca ele sa fie direct reutilizabile si in alte aplicatii
-in React, o componenta are cod HTML care sa ii ofere structura si cod JavaScript care sa ii ofere functionalitate si cosmetizare, toate intr-un singur loc

Exercises 2.19.-2.20
--------------------
-se continua "Phone book app"
-(?)

--------------------Part 1, Introduction to React--------------------

a. Introduction to React
----------------------------------------
npx create-react-app in_this_folder
-create-react-app = se compileaza automat la salvare
-to start the server, use npm start
-trebuia pus exact codul din index.js, fara serviceWorker ca sa mearga

Component
--------------------
-all content that needs to be rendered is defined as a React component
-React component = practic, o functie JavaScript
-codul scris intre acolade...
const App = () => {
..
}
...este evaluat si rezultatul este pus intre elementele (tag-urile) HTML si apoi randat pe pagina web

JSX
--------------------
-JSX = cod scris in componente React care se compileaza in cod JavaScript, vezi JSX-1.png
-JSX este ca un HTML dar care permite includerea de continut dinamic scris in JavaScript
-in JSX, tag-urile ca <br> trebuie inchise precum <br />

Multiple components
--------------------
-se pot scrie componente React care pot fi folosite de mai multe ori in aceeasi componenta-radacina <App />, de exemplu:
const Hello = () => {
  return (
    <div>
      <p>Hello world</p>
    </div>
  )
}
-va fi folosita astfel:
<Hello />

props: passing data to components
--------------------
-props = permit transmiterea de date componentelor, precum parametrii unei functii
-daca componenta <Hello /> permite transmiterea de date prin props...
const Hello = (props) => {
..
	<p> Hello {props.name} </p>
..
}...atunci in <App />, numele pe care il dam campului props, la noi "name" va fi folosit ca un atribut dintr-un tag HTML:
<Hello name="Adrian" />
-se pot folosi mai multe campuri pentru props: props.name, props.age, props.job, etc.

Some notes
--------------------
-always have the console open and console.log(messages_if_needed);
-componentele React se scriu cu litera mare, deci Footer nu e acelasi cu tag-ul <footer>
-<App /> trebuie sa contina cel putin un element-radacina, de ex. <div> => altfel, eroare de compilare
-se poate insa pune tag-uri goale <> si </> in loc de acel <div> si va compila cu succes si scapam de acel <div> care este intrinsec

Exercises 1.1, 1.2:
--------------------
rm -rf .git = pentru ca create-react-app face ca proiectul sa fie si un repo
-a trebuit sa fac un array pentru props pentru a il folosi precum voia cerinta 1.2

b. JavaScript
----------------------------------------
-transpilation = cod nou de JavaScript tradus in cod vechi care e compatibil cu toate browser-ele
-transpilation se face cu Babel si se face automat in React cu create-react-app
-Node.js = JavaScript runtime environment
node name_of_file.js = se ruleaza codul din name_of_file.js

Variables
--------------------
-tipul unei variabile cu let se poate schimba in timpul executiei

Arrays
--------------------
-un array declarat cu const poate fi modificat
-un array e un obiect
-forEach se aplica pentru fiecare element din array => poti aplica o functie pe fiecare element
-in React se prefara .concat(5) pentru a adauga 5 in array, spre deosebire de .push(5)
-concat() va returna un nou array
-functia .map() se poate aplica pentru fiecare element din array:
const m1 = t.map(value => value * 2)
-aici, se dubleaza fiecare element din array
-folosind destructuring assignment, parantezele drepte peste un array, de exemplu:
const t = [1, 2, 3, 4, 5]

const [first, second, ...rest] = t

console.log(first, second)	// 1, 2 is printed
console.log(rest)			// [3, 4 ,5] is printed
-destructuring assignment = face unpack de valori din array sau proprietati din obiecte

Objects
--------------------
-se pot adauga proprietati on the fly:
object1.address = 'Helsinki'
object1['secret number'] = 12341
-pentru 'secret number' trebuie sa folosim [] pentru ca avem spatiu in String si nu poate fi accesat cu .

Functions
--------------------
-se pot defini fara () si {}...
const square = p => p * p
...daca iau un singur parametru si daca sunt functii cu o singura instructiune
-folosite impreuna cu .map():
const t = [1, 2, 3]
const tSquared = t.map(p => p * p)
-functiile se pot folosi asa...
const average = function(a, b) {..}
const result = average(2, 5)
...sau asa:
function product(a, b) {..}
const result = product(2, 6)

Exercises 1.3-1.5:
--------------------
-se continua in ex_1.1
-se recomanda printarea props pentru a vedea exact ce parametru primeste componenta React
-a trebuit sa pun props.content ca sa ajung la continutul part1, part2 si part3 din <App />

Object methods and "this"
--------------------
-nu avem nevoie sa definim obiecte cu metode cand folosim React hooks, vezi (https://reactjs.org/docs/hooks-intro.html)
const referenceToAddition = arto.doAddition
referenceToAddition(10, 15)	// 25 is printed
-referenceToAddition este o referinta la metoda doAddition() din obiectul arto:
const arto = {
	name: 'Arto Hellas',
	..
	greet: function() {
		console.log('hello, my name is ' + this.name)
	},
	doAddition: function(a, b) {
		console.log(a + b)
	},
}
-se pierde referinta la obiectul arto daca folosim o referinta la metoda greet() din arto:
arto.greet()		// "hello, my name is Arto Hellas" gets printed
const referenceToGreet = arto.greet
referenceToGreet()	// prints "hello, my name is undefined"
-se observa ca referenceToGreet() nu mai indica obiectul arto corespunzator
-de asemenea, valoarea lui "this" se modifica in functie de cum s-a facut apelul catre functia respectiva
.in cazul nostru, printr-o referinta, fie referenceToAddition, fie referenceToGreet, "this" nu se refera la obiectul "arto", ci la obiectul global, vezi (https://developer.mozilla.org/en-US/docs/Glossary/Global_object) si de aceea returneaza "undefined" pentru ca nu gaseste numele "Arto Hellas"
-daca engine-ul de JavaScript apeleaza referenceToAddition sau referenceToGreet atunci prin "this" se va referi la obiectul global si nu la "arto"
-folosind bind, se creeaza o functie noua care va lucra exclusiv cu obiectul "arto" indiferent de unde si cum este metoda greet() apelata:
setTimeout(arto.greet.bind(arto), 1000)
-arrow functions nu functioneaza deloc cu "this"

Classes
--------------------
-la baza unei clase sta tot un Object

JavaScript materials
--------------------
You-Don't-Know-JS = (https://github.com/getify/You-Dont-Know-JS) = book cu repo
javascript.info
egghead.io
(https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript):
-sunt diferente intre parseInt() si parseFloat()
-undefined e o constanta
-false, 0, empty strings (""), NaN, null, and undefined sunt toate false, oricare altul este true
-truthy si falsy se refera la valori care pot lua valori adevarate, respectiv false
-de exemplu, alea de mai sus care sunt toate false se numesc valori falsy
-doar functiile au scope, deci o variabila declarata cu var e vizibila in toata functia, chiar daca poate variabila var a fost declarata in interiorul unui if(..)
-doar let si const iti permit block-scoped variables
'3' + 4 + 5;  // "345"
 3 + 4 + '5'; // "75"
-=== verifica si tipul variabilelor pentru care se testeaza egalitatea
for (let value of array) {
  // do something with value, BUN pentru array!
}
for (let property in object) {
  // do something with object property, BUN pentru obiecte!
}
-&& si || se executa mai departe doar daca partea din stanga este adevarata:
var name = o && o.getName();	//null-value checking
var obj = {}; = cum se creeaza un nou obiect
-.length dintr-un array returneaza index-ul maxim din array + 1 =>
var a = ['dog', 'cat', 'hen'];
a[100] = 'fox';
a.length; // 101
-cu alte cuvinte, .length nu returneaza neaparat numarul de elemente din array
-o functie care primeste un numar variabil de parametri:
function avg(...args) {..}
.args va fi un array de valori primite ca parametru din apel de genul:
avg(2, 3, 4, 5);
...args = rest arguments, in ...args sunt "rest of the arguments"
-functiile sunt obiecte in JavaScript
-daca apelezi o functie a unui obiect (metoda) cu .functi() sau ['functie], prin "this" se refera la obiectul curent
-daca functia se apeleaza printr-o referinta, cum am vazut mai sus, "this" se refera la obiectul global
-keyword "new" (?)
-deoarece .prototype este un obiect partajat de toate instantele Person, toate campurile sau metodele asignate pe Person.prototype sunt valabile tuturor instantelor prin "this" (?)
.practic asta iti permite sa adaugi campuri si metode on the fly
-apply() asteapta ca prim parametru obiectul care ar trebui tratat ca "this", ca obiectul curent
-functiile imbricate au acces la variabilele din scope-ul functiei din care fac parte
-obiectul global poate fi accesat prin "this" in cod sau prin "window" in browser
-de fiecare data cand JavaScript executa o functie, se creeaza un 'scope' object care retine toate variabilele locale create inauntrul acelei functii
-este asemanator cu acel obiect global, dar acest obiect nu poate fi accesat direct din cod sau iterat peste proprietatile acestuia
-aceste 'scope' objects formeaza "scope chain" si impreuna cu functiile in care au fost create (sau care au determinat la creearea lor) formeaza "closures"

c. Component state, event handlers
----------------------------------------
Component helper functions
--------------------
-o functie definita in interiorul unei componente React are acces la props
-functions within functions are common in JavaScript

Destructuring
--------------------
-destructuring permite despachetarea componentelor din props, aici name si age:
const Hello = (props) => {
	const { name, age } = props
	..
}
-mai mult, despachetarea poate avea loc in antetul functiei:
const Hello = ({ name, age }) => {..}
-se foloseste atunci cand vrem ca proprietatile props.name si props.age sa nu mai fie transmise printr-un obiect props, ci sa fie direct asignate variabilelor name si age

Page re-rendering
--------------------
-se poate folosi functia setInterval()
-page re-rendering nu se face prin apel de ReactDOM.render

Stateful component
--------------------
-page re-rendering se face folosind React hooks importand { useState } from 'react'
-folosind useState(0) practic se adauga o "stare" (state) componentei React numita Counter
-setCounter() va reprezenta o functie care va modifica starea componentei prin variabila "counter"
-setCounter() se apeleaza din setTimeout() la o secunda dupa ce setTimeout() a fost apelat:
setTimeout(
	() => setCounter(counter + 1),
	1000
)
-daca se apeleaza setCounter(), componenta React se re-randeaza
-de fiecare data cand se modifica variabila counter prin apel de setCounter(), componenta React se re-randeaza

Event handling
--------------------
-<button> are atributul onClick cu care putem asigna un event handler:
<button onClick={ handlePlus }>
-se foloseste tot functia setCounter() dar de data asta va fi apelata din interiorul event handler-ului numit "handlePlus" sau "resetCounter"

Event handler is a function
--------------------
-in onClick={..} trebuie pusa o functie sau o referinta la o functie, nu merge direct apelul catre setCounter()
-nu se recomanda definirea de event handler astfel...
<button onClick={() => setCounter(counter + 1)}>
...ci se recomanda creearea unei functii separate care sa fie apelate din onClick={..}:
<button onClick={increaseByOne}>

Passing state to child components
--------------------
-cand vrem ca o "stare" (state) sa reflecte aceeasi schimbare a componentei, in cazul nostru, vrem ca starea counter-ului sa fie uniforma peste intregul index.js, adica increaseByOne si decreaseByOne si setToZero sa se refere la aceeasi stare a counter-ului
-lift the state up = atunci aceasta "stare" se urca in ierarhie componentelor React spre cel mai apropiat stramos (ancestor)
-am folosit o componenta React de tip buton care primeste o functie prin props: increaseByOne, decreaseByOne si setToZero

Changes in state cause rerendering
--------------------
-fiecare apel care modifica starea determina componenta React sa se re-randeze
-cand porneste aplicatia, se ruleaza codul din <App />
-folosind state hooks prin useState se atribuie lui <App /> o "stare" prin variabila counter care initial ia valoarea 0 pentru ca am folosit useState(0)
.useState(0) returneaza un stateful value, acel counter si o functie care poate modifica starea acestui counter, functia setCounter()
-in <App /> avem <Display> si trei <Button>
-fiecare <Button> are un event handler care schimba starea counter-ului
-la fiecare schimbare de stare, se determina re-randarea componentei React
-cand se re-randeaza <App /> practic se re-randeaza si celelalte componente <Display> si <Button>

Refactoring the components
--------------------
-in VSC, shortcut e F2

d. A more complex state, debugging React apps
----------------------------------------
Complex state
--------------------
-useState poate fi folosit pentru a crea mai multe "stari"
-object spread syntax, acel ...clicks:
const handleRightClick = () => {
	const newClicks = { 
		...clicks, 
		right: clicks.right + 1 
	}
	setClicks(newClicks)
}
-...clicks = face o copie a obiectului clicks si creeaza astfel un nou obiect clicks
-nu este necesara asignarea in variabila newClicks pentru a face modificari asupra clicks.right:
const handleRightClick = () =>
	setClicks({ ...clicks, right: clicks.right + 1 })
-este interzisa modificarea "starii" in mod direct:
const handleRightClick = () => {
	clicks.right++
	setClicks(clicks)
}
-se observa ca prin object spread syntax de mai sus, am creat un nou obiect clicks prin copierea celui vechi => asta este modul de lucru cu stari in React
-schimbarea starii in React se face prin crearea unui nou obiect in care sa se reflecte aceasta noua stare
.cu alte cuvinte, cand se schimba starea, se creeaza un nou obiect in care se "retine" aceasta "stare" si nu se modifica "starea" in mod direct
-de asemenea, faptul ca am folosit un useState(0) pentru left si un useState(0) pentru right a fost o idee mai buna decat folosirea unui singur useState pentru ca nu a complicat in mod inutil codul si nu aduce niciun beneficiu folosirea unui singur useState

Handling arrays
--------------------
-in loc de useState(), am folosit...
const [allClicks, setAll] = useState([])
...unde allClicks se initializeaza acum cu un array gol si nu cu integer 0
-retinem ca prin .concat()...
setAll(allClicks.concat('L'))
...se creeaza un array nou
-din nou, se recomanda .concat() si nu .push() pentru ca .push() ar modifica in mod direct "starea" obiectului allClicks si noi vrem ca noua schimbare sa fie reflectata intr-un obiect nou
-se foloseste .join(' ') pe allClicks pentru a impreuna toate caracterele intr-un singur String despartite de cate un ' '

Conditional rendering
--------------------
-conditional rendering = poti randa diferite componente React in functie de "starea" unei componente
-de exemplu, poti randa instructiunea "Folositi butoanele" daca allClicks are lungimea 0 sau poti randa chiar vectorul allClicks, adica un sir de genul "L L R L..." daca lungimea este diferita de 0
-practic, componenta <History> are doua declaratii return, in functie de lungimea allClicks

Old React
--------------------
-inaintea de folosirea React hooks, se foloseau clase JavaScript pentru componentele React care aveau nevoie de definirea de "stare"
-aceste clase se numesc React class components

Debugging React applications
--------------------
-find and fix the problems immediately
-e mai simplu de facut debug atunci cand nu despachetam direct in antet obiectul props, pentru a il putea folosi intr-un console.log():
const Button = (props) => {
	console.log(props)
	..
}
-de asemenea, se recomanda in console.log() separarea prin virgula:
console.log('props value is', props)
-folosind keyword debugger oriunde in cod, executia codului se opreste in browser si se poate inspecta tab-ul "Debugger" => debugger e un fel de breakpoint
-din tab-ul "Debugger", daca intri pe fisierul .js se pot pune breakpoints dand click pe linia corespunzatoare
-starile, in React Dev Tools (Components) nu sunt afisate in ordinea in care au fost definite in fisierul .js

Rules of Hooks
--------------------
-React hooks trebuie apelate neaparat din interiorul functiilor care definesc componentele React
-nu trebuie apelate din if(), for(), etc. sau din functions with functions

Event Handling Revisited
--------------------
-butonul reactioneaza la evenimentul de click printr-un event handler
-event handler = mereu functii sau referinte catre functii, niciodata variabila sau orice alt tip in afara de functie sau referinta catre functie
-in exemplul de mai jos, event handler-ul este o functie...
<button onClick={console.log('clicked the button')}>
...dar este de fapt un apel catre functia console.log(), ceea ce inseamna ca pentru onClick se va atribui valoarea returnata de apelul catre functia console.log() => undefined in acest caz
-abordarea corecta este...
<button onClick={() => console.log('clicked the button')}>
...unde lui onClick i se atribuie o referinta catre arrow function, catre acel () => ..
<button onClick={setValue(0)}>button</button> = cauzeaza un infinte loop pentru ca la fiecare render de pagina se apeleaza setValue(0)

Function that returns a function
--------------------
-definitiile celor doua functii sunt echivalente:
const hello = (who) => {
	const handler = () => console.log('hello', who)
	return handler
}
const hello = (who) => () => {
	console.log('hello', who)
}
-deoarece hello() returneaza functia handler() inseamna ca i se poate atribui lui onClick, deci practic...
<button onClick={hello('world')}>
...devine:
<button onClick={() => console.log('hello world')}> // unde 'world' este valoarea parametrului 'who'
-definind astfel functia hello() o putem personaliza prin acest parametr 'who'
-functiile care returneaza functii sunt folositoare in scrierea de cod generic, de exemplu o functie care sa reseteze counter-ul la o valoarea custom, 0, 50, 100, 1000, etc.:
<button onClick={setToValue(1000)}>thousand</button>
-codul generic insa se poate scrie si direct:
<button onClick={() => setToValue(1000)}>
-it's a matter of choice between the two

Passing Event Handlers to Child Components
--------------------
-trebuie sa coincida atributul cu numele de props transmis componentei:
<Button onClick={resetRightClick} text='reset right to 0' />
const { onClick, text } = props
-onClick si text din <Button> coincide cu onClick si text din componenta React

Do Not Define Components Within Components
--------------------
-componenta <Button> a fost definita in afara <App /> => metoda corecta de a defini componente React

Useful Reading
--------------------
-(https://egghead.io/courses/the-beginner-s-guide-to-reactjs) = un tutorial bun de React care foloseste React hooks in loc de React class components
-de asemenea, documentatia oficiala este recomandata (https://reactjs.org/docs/hello-world.html)

Exercises 1.6-1.14:
--------------------
1.6
-de ce nu a mers sa fac o functie giveFeedback() care sa primeasca pe rand ca parametru pe good, bad si neutral (?)
1.11
-vezi (https://github.com/facebook/react/issues/5652#issuecomment-164175731) explicatie pentru ce <tr> si <td> trebuie incluse intr-un <tbody>..</tbody>
11.14
-a trebuit sa pun ... in Math.max() sa imi calculeze maximul din array:
const maxVotes = Math.max(...anecdotesVotes);
-nu iti da eroare daca nu se potriveste atributul din componenta cu numele cu care il apelezi din <App />, gen 'anecodote' diferit de 'anecdote' dar nu da eroare
-mi-a ramas un mic bug: atunci cand votez o anecdota, in 'Anecdote with most views' ramane scorul cu unul in minus, adica ramane in urma, chiar daca actualizez starea obiectului la fiecare apasare de buton (?)

--------------------Part 0, Fundamentals of Web apps--------------------

Fundamentals of Web apps
----------------------------------------
-F12 = opens Console
-Preserve log = logs printed by the app as the page is reloaded
-Disable cache in the Network tab
-Status code 200 = successful request
-Headers, Respons
-Content-Type in Response Headers: text/html, charset=utf-8
-browser uses information from the Content-Type to properly display web page
-the HTML page begins to render before the image kuva.png has been fetched from the server
-"dumb" browser = when all the logic behind the app is on the server and the browser just displays the results
-web servers can be created with Express and Node.js
-does an HTTP GET request to the server:
xhttp.open('GET', '/data.json', true)
-the notes list is populated from the .json file

Event handlers and Callback functions
--------------------
xhttp.onreadystatechange = function () {..} = an event handler for event onreadystatechange is defined for the xhttp object doing the request
-when the state of the object changes, the browser calls the event handler function, function()
-readyState 4 of a XMLHttpRequest means "The operation is complete"
-callback functions = event handler functions
-the runtime environment, in our case the browser, invokes these functions at an appropriate time, when an event has occured

Document Object Model or DOM
--------------------
-depicting HTML elements as a tree
-DOM enables programmatic modification of these HTML elements
-DOM is an API = application programming interface

Manipulating the document-object from console
--------------------
-daca scrii document in consola, iti da acces la obiectul document care sta la radacina unui arbore DOM => document este un obiect
-poti folosi consola sa adaugi continut elementelor originale din pagina, pur si simplu scrii cod in Console ca si cum ai scrie in VSC

CSS
--------------------
-clasa incepe cu . in .css
-id incepe cu # in .css

Loading a page containing JavaScript - revised
--------------------
-dupa ce s-a incarcat fisierul data.json se invoca functia (event handler) care scrie in format HTML (cu <ul> si <li>) continutul "notes" folosind API-ul DOM

Forms and HTTP POST
--------------------
-stilul vechi de a reflecta modificarile aduse in "notes" folosind redirect si un al doilea request GET catre server

AJAX
--------------------
-AJAX = Asynchronous JavaScript and XML
-AJAX e folosit pentru a incarca continutul paginii web prin cod JavaScript inclus in cod HTML, fara a re-randa (re-render) pagina

Single page app
--------------------
-in single page app (SPA), exista o singura pagina HTML al carui continut este modificat de catre scriptul JavaScript incarcat de pe server si executat de catre browser
-stil vechi: o noua intrare in "notes" se face la o pagina separata /new_note si se afiseaza continutul actualizat in urma unui redirect
-pe stilul nou, nu se mai foloseste atributul "action" si "method" dintr-un element <form> => se face un singur request catre server
-(https://httpstatuses.com/201) = status codes HTTP
-se creeaza o functie callback care sa fie apelata cand se apasa pe butonul "Save"
-prin...
e.preventDefault()
...se impiedica crearea unei al doilea GET request catre server

JavaScript-libraries
--------------------
-JQuery
-Angular, React + Redux, VueJS

Full stack -web development
--------------------
-folosim JavaScript pe toate stivele frontend, backend, database stack

JavaScript fatigue
--------------------
-JavaScript technologies are being developed fast and can be hard and stressful to stay on top of new things that are emerging

Exercises:
--------------------
-HTML: tag, attribute, attribute value and element
-CSS: selector, property, property value and declaration
-you have different types of selectors: element, ID, class, attribute
margin: 0 auto; = marginea e 0 pe top si bottom si auto pe stanga si dreapta
padding: 0 20px 20px 20px; = top, right, bottom, left
-block element = element care ocupa spatiu in pagina, <body>...
-inline element = element care nu poate primi atribute ca margin sau padding, <img>...
-trebuie folosit display: block; pentru ca elementele inline sa se comporte ca un block
-<form> e un container de elemente
-se recomanda folosirea atributelor "action" si "method"
-"action" = unde se trimit datele introduse in form
-"method" = GET sau POST
-folosind for se asociaza un label cu textbox-ul in care se introduc datele:
<label for="mail">E-mail:</label>
<input type="email" id="mail" name="user_email">
-valoarea implicita pentru <input> se pune prin atributul "value", dar valoarea implicita pentru <textarea> se pune aici, in interior </textarea>
-valorile din <form> sunt trimise catre server ca perechi nume/valoare, de exemplu textarea/"Buna ziua, va scriu..." => trebuie folosit atributul "id" pe fiecare camp din <form>







